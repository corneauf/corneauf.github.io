---
layout: post
title: Delving into libc++ - part 2: `from_chars` and the task ahead.
categories: [libc++, C++]
---
Before we step into the details of what a floating point is or what the insides of the libc++ code look like, we should take a moment and ask ourselves: what is `from_chars`?

To answer this question we will look at three sources which all contain parts of the answer. First one on the docket: [cppreference](https://en.cppreference.com/w/cpp/utility/from_chars)

We find something interesting stuff already. For one, the signature of `from_chars`

```
std::from_chars_result
    from_chars( const char* first, const char* last,
                /* floating-point-type */& value,
                std::chars_format fmt = std::chars_format::general );
```
Seems to return some kind of result, takes in pointers to a first and last character. Interestingly, it takes in a floating point type by _reference_ which we do not see often in the standard. Finally it takes in some kind of format specifier. Let's break it point by point.

<!--more-->

`std::from_chars_result`: this class contains two things: a `const char*` to the first character _not_ matching the pattern (which we will talk about later) then an `std::errc` object which specifies whether an error happened or not. In the case it did, then the return `std::errc` will simply be `std::errc{}` and the class offers an overload of `==` to check this. Otherwise, the value is either `std::errc::invalid_argument` or `std::errc::result_out_of_range`.

`const char* first` and `const char* last`: As mentionned in the last blog, taking an `std::string` would incure unnecessary copies so we got with `const char*`. This allows us to use `std::string_view` and `std::from_chars` to obtain basically have zero copy. Understandably, `first` and `last` must be a valid range.

`/* floating-point-type */& value`: The wording changed in 2023
